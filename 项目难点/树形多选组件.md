# 树形多选组件

## 需求背景

 实现一个可搜索树形多选组件，当子节点全部选中的时候，只传父节点的值，否则传子节点

## 错误判断

因为在ng-zorro中，这个逻辑是默认的，于是我很爽快的答应了后端这样做。但是在antd react版本中，子节点全选中会把所有子节点和父节点都传出，和需求商讨的方案是不同的，于是我需要自己实现。

## 选择逻辑难点分析

在选中或取消某个节点时，可以拿到当前节点的树结构和对应关系。

1. 当节点作为父节点时，很容易去判断去掉它的子节点。
2. 当节点作为子节点时，**难点**来了，需要判断它的兄弟节点及它兄弟节点的全部子节点是否全部选中，然后如果全中，在用当前节点的父节点走作为父节点的逻辑还要再走作为子节点的逻辑

## 选择逻辑具体实现

将存在于children数组的节点值存放到一个 Set对象里，然后用选中的节点值过滤掉Set当中的值

~~~js
 const onCheck = (checkedKeysValue: KeyType[], e: any) => {
    const childrenSet = new Set();
    const checkedNodes = e.checkedNodes;

    checkedNodes?.forEach((node: RealDataNode) => {
      const curChildren = node?.children;
      if (curChildren && !!curChildren?.length) {
        curChildren.forEach((childNode) => {
          const curKey = childNode.uid;
          if (!childrenSet.has(curKey)) {
            childrenSet.add(curKey);
          }
        });
      }
    });
    // 选中的节点值
    const handledKeys = checkedKeysValue.filter(
      (key: KeyType) => !childrenSet.has(key)
    );
    setCheckedKeys(handledKeys);
 }
~~~

### 搜索逻辑难点分析

多选搜索的实现是按照节点的名称去匹配搜索框中的值，将name截段替换成Element。大致如下：

~~~js
 /** 根据搜索关键字做高亮处理 */
  const realTreeData = useMemo(() => {
    if (!treeData) {
      return [];
    }
    if (!searchValue) {
      return treeData;
    }
    const loop = (data: TeamResData[]): TeamResData[] =>
      data.map((item) => {
        const strTitle = item.name as string;
        const index = strTitle.indexOf(searchValue);
        const beforeStr = strTitle.substring(0, index);
        const afterStr = strTitle.slice(index + searchValue.length);
        // 控制展开树节点的变化
        // if (index > 0) {
        //   setExpandedKeys((row) => [...row, item.uid]);
        // } else {
        //   const expandedKeysCopy = [...expandedKeys];
        //   expandedKeysCopy.splice(index, 1);
        //   setExpandedKeys(expandedKeysCopy);
        // }
        const name =
          index > -1 ? (
            <span>
              {beforeStr}
              <span className={styles.searchValue}>{searchValue}</span>
              {afterStr}
            </span>
          ) : (
            <span>{strTitle}</span>
          );
        if (item.children) {
          return { ...item, name, children: loop(item.children) };
        }
        return {
          ...item,
          name,
        };
      });
    return loop(treeData);
  }, [searchValue, treeData]);
~~~

问题在于搜索之后树节点的展开逻辑，按照官网推荐的逻辑算法，不适用于多选的逻辑，通过递归判断关键字配配值数组与树节点数组的相交，不够理想。于是我在这段逻辑这加入了`控制展开树节点的变化` 这段注释掉的代码，处理高亮文字逻辑的时候就把高亮的节点值存放在**受控展开节点数组**中，结果react渲染报错

思考一下逻辑，在遍历树组件当中，使用了太多次`setExpandedKeys` 如果我在局部维护一个数组